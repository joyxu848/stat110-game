{% extends "layout.html" %}

{% block title %}
    Study Break
{% endblock %}

{% block main %}
<div class="study-break-wrapper d-flex justify-content-center">
    <div class="study-break-content d-flex flex-column align-items-center justify-content-center">

        <!-- OVERHEAD STREET SIGN + TRAFFIC LIGHTS -->
        <div class="overhead-structure">
            <div class="overhead-pole"></div>
            <div class="overhead-gantry"></div>

            <div class="street-sign">
                Welcome to Blotchville
            </div>

            <div class="street-sign-hanger left"></div>
            <div class="street-sign-hanger right"></div>

            <div class="traffic-light left">
                <div class="light red"></div>
                <div class="light yellow"></div>
                <div class="light green"></div>
            </div>

            <div class="traffic-light right">
                <div class="light red"></div>
                <div class="light yellow"></div>
                <div class="light green"></div>
            </div>
        </div>

        <!-- SCORE + BUTTON + GAME CANVAS -->
        <div class="mb-2">
            <span class="fw-bold">Score:</span>
            <span id="score">0</span>
        </div>

        <button id="startButton" class="btn btn-primary mb-3">
            Start Game
        </button>

        <canvas id="gameCanvas" width="600" height="400" class="study-game-canvas"></canvas>

        <p id="status" class="mt-3 fw-bold"></p>
    </div>
</div>

<script>
    (function () {

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const scoreEl = document.getElementById("score");
        const statusEl = document.getElementById("status");
        const startButton = document.getElementById("startButton");

        // Horizontal lanes
        const laneCount = 3;
        const laneHeight = canvas.height / laneCount;
        const laneCenters = [];
        for (let i = 0; i < laneCount; i++) {
            laneCenters.push(i * laneHeight + laneHeight / 2);
        }

        // Player bus (moves up/down)
        const bus = {
            lane: 1,
            x: 40,
            width: 90,
            height: 60
        };

        let cars = [];
        let running = false;
        let lastFrameTime = 0;
        let lastSpawnTime = 0;
        let spawnInterval = 900;
        let score = 0;

        function resetGame() {
            bus.lane = 1;
            bus.x = 40;
            cars = [];
            running = false;
            lastFrameTime = 0;
            lastSpawnTime = 0;
            score = 0;
            scoreEl.textContent = "0";
            statusEl.textContent = "";
        }

        // Check if adding a car in (candidateLane, candidateX) would create
        // a "wall" where all lanes are blocked in a critical window.
        function wouldCreateWall(candidateLane, candidateX) {
            // Define the "danger window" in front of the bus.
            // You can tweak these numbers to change how far ahead the check looks.
            const windowStart = 180;
            const windowEnd = 380;

            const lanesBlocked = new Set();

            // Existing cars that block the window
            for (let car of cars) {
                const carLeft = car.x;
                const carRight = car.x + car.width;

                // If this car overlaps the window horizontally
                if (!(carRight < windowStart || carLeft > windowEnd)) {
                    lanesBlocked.add(car.lane);
                }
            }

            // Now consider the candidate new car
            const candLeft = candidateX;
            const candRight = candidateX + 90;  // 90 = car width in your code
            if (!(candRight < windowStart || candLeft > windowEnd)) {
                lanesBlocked.add(candidateLane);
            }

            // If all lanes are blocked, this spawn would create an impossible wall
            return lanesBlocked.size === laneCount;
        }


        function spawnCar() {
            const speed = 220 + Math.random() * 100;
            const spawnX = canvas.width + 120;

            // Try lanes in random order so it still feels varied
            const possibleLanes = [0, 1, 2].sort(() => Math.random() - 0.5);
            let chosenLane = null;

            for (let lane of possibleLanes) {
                if (!wouldCreateWall(lane, spawnX)) {
                    chosenLane = lane;
                    break;
                }
            }

            // If every lane would create a wall, skip spawning this frame.
            if (chosenLane === null) {
                return;
            }

            cars.push({
                lane: chosenLane,
                x: spawnX,
                width: 90,
                height: 60,
                speed: speed,
            });
        }

                function update(dt) {
            // Move cars left
            for (let car of cars) {
                car.x -= car.speed * dt;
            }

            // Remove cars off-screen
            cars = cars.filter(car => car.x > -150);

            // Collision check
            for (let car of cars) {
                if (car.lane === bus.lane) {
                    const busLeft = bus.x;
                    const busRight = bus.x + bus.width;
                    const carLeft = car.x;
                    const carRight = car.x + car.width;

                    const overlap = !(busRight < carLeft || busLeft > carRight);
                    if (overlap) {
                        endGame();
                        return;
                    }
                }
            }

            // Score
            score += dt * 10;
            scoreEl.textContent = Math.floor(score);
        }


        function drawRoad() {
            ctx.fillStyle = "#333";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "#bbb";
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]);

            for (let i = 1; i < laneCount; i++) {
                const y = i * laneHeight;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        function drawBus() {
            const y = laneCenters[bus.lane] - bus.height / 2;

            ctx.fillStyle = "#4da6ff";
            ctx.fillRect(bus.x, y, bus.width, bus.height);

            ctx.fillStyle = "#e6f2ff";
            ctx.fillRect(bus.x + 10, y + 10, bus.width - 20, 15);

            ctx.fillStyle = "#111";
            ctx.fillRect(bus.x + 8, y + bus.height - 16, 16, 12);
            ctx.fillRect(bus.x + bus.width - 24, y + bus.height - 16, 16, 12);
        }

        function drawCars() {
            for (let car of cars) {
                const y = laneCenters[car.lane] - car.height / 2;

                ctx.fillStyle = "#ff5c5c";
                ctx.fillRect(car.x, y, car.width, car.height);

                ctx.fillStyle = "#ffff99";
                ctx.fillRect(car.x + 10, y + car.height - 10, 14, 6);
                ctx.fillRect(car.x + car.width - 24, y + car.height - 10, 14, 6);
            }
        }

        function draw() {
            drawRoad();
            drawBus();
            drawCars();
        }

        function endGame() {
            running = false;
            statusEl.textContent = "Crash! Press Start Game to try again.";
            startButton.textContent = "Play Again";

            ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#fff";
            ctx.font = "24px system-ui, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText("Score: " + Math.floor(score), canvas.width / 2, canvas.height / 2 + 24);
        }

        function gameLoop(timestamp) {
            if (!running) return;

            if (!lastFrameTime) lastFrameTime = timestamp;
            const dt = (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;

            if (!lastSpawnTime) lastSpawnTime = timestamp;
            if (timestamp - lastSpawnTime > spawnInterval) {
                spawnCar();
                lastSpawnTime = timestamp;
                if (spawnInterval > 400) spawnInterval -= 10;
            }

            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Up/down controls
        document.addEventListener("keydown", function (event) {
            if (!running) return;
            if (event.key === "ArrowUp" && bus.lane > 0) {
                bus.lane -= 1;
                event.preventDefault();
            } else if (event.key === "ArrowDown" && bus.lane < laneCount - 1) {
                bus.lane += 1;
                event.preventDefault();
            }
        });

        startButton.addEventListener("click", function () {
            resetGame();
            running = true;
            startButton.textContent = "Restart";
            requestAnimationFrame(gameLoop);
        });

        drawRoad();
        drawBus();
    })();
</script>
{% endblock %}
